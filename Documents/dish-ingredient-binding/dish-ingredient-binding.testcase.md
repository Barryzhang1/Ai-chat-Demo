# 菜品绑定库存食材功能测试用例

## 测试用例概览

本文档包含菜品绑定库存食材功能的完整测试用例，覆盖后端API、前端UI和集成测试场景。

---

## 1. 后端API测试

### 1.1 创建菜品 - 绑定食材

#### 测试用例 1.1.1：创建菜品时绑定单个食材
**测试目标**：验证创建菜品时可以绑定一个食材

**前置条件**：
- 库存中存在食材：`鸡肉`（ID: `507f1f77bcf86cd799439011`）

**测试步骤**：
1. 发送POST请求到`/dish`
2. 请求体包含：
```json
{
  "name": "白切鸡",
  "price": 48,
  "categoryId": "65a1b2c3d4e5f678901234a",
  "description": "鲜嫩白切鸡",
  "tags": ["招牌菜"],
  "ingredients": ["507f1f77bcf86cd799439011"]
}
```

**期望结果**：
- 响应状态码：201
- 返回的菜品对象包含`ingredients`字段
- `ingredients`数组包含一个元素：`"507f1f77bcf86cd799439011"`

---

#### 测试用例 1.1.2：创建菜品时绑定多个食材
**测试目标**：验证创建菜品时可以绑定多个食材

**前置条件**：
- 库存中存在食材：
  - `鸡肉`（ID: `507f1f77bcf86cd799439011`）
  - `花生`（ID: `507f191e810c19729de860ea`）
  - `辣椒`（ID: `507f191e810c19729de860eb`）

**测试步骤**：
1. 发送POST请求到`/dish`
2. 请求体包含：
```json
{
  "name": "宫保鸡丁",
  "price": 38,
  "categoryId": "65a1b2c3d4e5f678901234a",
  "description": "经典川菜",
  "tags": ["招牌菜", "微辣"],
  "ingredients": [
    "507f1f77bcf86cd799439011",
    "507f191e810c19729de860ea",
    "507f191e810c19729de860eb"
  ]
}
```

**期望结果**：
- 响应状态码：201
- 返回的菜品对象包含`ingredients`字段
- `ingredients`数组包含3个元素，顺序与请求一致

---

#### 测试用例 1.1.3：创建菜品时不绑定食材
**测试目标**：验证不绑定食材也能正常创建菜品（向后兼容）

**测试步骤**：
1. 发送POST请求到`/dish`
2. 请求体不包含`ingredients`字段：
```json
{
  "name": "清炒时蔬",
  "price": 18,
  "categoryId": "65a1b2c3d4e5f678901234a",
  "description": "当季时蔬"
}
```

**期望结果**：
- 响应状态码：201
- 返回的菜品对象包含`ingredients`字段
- `ingredients`为空数组：`[]`

---

#### 测试用例 1.1.4：创建菜品时传入空数组
**测试目标**：验证传入空数组的处理

**测试步骤**：
1. 发送POST请求到`/dish`
2. 请求体包含空的`ingredients`数组：
```json
{
  "name": "凉拌黄瓜",
  "price": 12,
  "categoryId": "65a1b2c3d4e5f678901234a",
  "ingredients": []
}
```

**期望结果**：
- 响应状态码：201
- 返回的菜品对象`ingredients`为空数组：`[]`

---

#### 测试用例 1.1.5：创建菜品时传入无效的食材ID格式
**测试目标**：验证食材ID格式校验

**测试步骤**：
1. 发送POST请求到`/dish`
2. 请求体包含无效格式的食材ID：
```json
{
  "name": "测试菜品",
  "price": 20,
  "categoryId": "65a1b2c3d4e5f678901234a",
  "ingredients": ["invalid-id", "12345"]
}
```

**期望结果**：
- 如果后端做格式校验：响应状态码400，返回错误信息
- 如果后端不做格式校验：响应状态码201，接受任意字符串ID（推荐此方案，灵活性更高）

---

### 1.2 更新菜品 - 修改食材绑定

#### 测试用例 1.2.1：更新菜品时添加食材
**测试目标**：验证可以为已有菜品添加食材绑定

**前置条件**：
- 已存在菜品：`宫保鸡丁`（ID: `65a1b2c3d4e5f6789012345`），当前`ingredients`为空数组

**测试步骤**：
1. 发送PUT请求到`/dish/65a1b2c3d4e5f6789012345`
2. 请求体包含：
```json
{
  "ingredients": [
    "507f1f77bcf86cd799439011",
    "507f191e810c19729de860ea"
  ]
}
```

**期望结果**：
- 响应状态码：200
- 返回的菜品对象`ingredients`包含2个元素

---

#### 测试用例 1.2.2：更新菜品时移除部分食材
**测试目标**：验证可以移除已绑定的部分食材

**前置条件**：
- 已存在菜品：`宫保鸡丁`，当前`ingredients`为`["507f1f77bcf86cd799439011", "507f191e810c19729de860ea", "507f191e810c19729de860eb"]`

**测试步骤**：
1. 发送PUT请求到`/dish/:id`
2. 请求体包含：
```json
{
  "ingredients": ["507f1f77bcf86cd799439011"]
}
```

**期望结果**：
- 响应状态码：200
- 返回的菜品对象`ingredients`只包含1个元素

---

#### 测试用例 1.2.3：更新菜品时清空所有食材
**测试目标**：验证可以清空所有食材绑定

**前置条件**：
- 已存在菜品，当前有绑定食材

**测试步骤**：
1. 发送PUT请求到`/dish/:id`
2. 请求体包含：
```json
{
  "ingredients": []
}
```

**期望结果**：
- 响应状态码：200
- 返回的菜品对象`ingredients`为空数组

---

#### 测试用例 1.2.4：更新菜品时增加新食材
**测试目标**：验证可以在现有基础上增加食材

**前置条件**：
- 已存在菜品，当前`ingredients`为`["507f1f77bcf86cd799439011"]`

**测试步骤**：
1. 发送PUT请求到`/dish/:id`
2. 请求体包含：
```json
{
  "ingredients": [
    "507f1f77bcf86cd799439011",
    "507f191e810c19729de860ea",
    "507f191e810c19729de860ec"
  ]
}
```

**期望结果**：
- 响应状态码：200
- 返回的菜品对象`ingredients`包含3个元素

---

### 1.3 查询菜品 - 返回食材信息

#### 测试用例 1.3.1：查询单个菜品返回食材信息
**测试目标**：验证查询菜品时返回`ingredients`字段

**前置条件**：
- 已存在菜品，绑定了2个食材

**测试步骤**：
1. 发送GET请求到`/dish/:id`

**期望结果**：
- 响应状态码：200
- 返回的菜品对象包含`ingredients`字段
- `ingredients`是数组类型

---

#### 测试用例 1.3.2：查询菜品列表返回食材信息
**测试目标**：验证查询菜品列表时所有菜品都包含`ingredients`字段

**测试步骤**：
1. 发送GET请求到`/dish`

**期望结果**：
- 响应状态码：200
- 返回的菜品数组中，每个菜品对象都包含`ingredients`字段
- 未绑定食材的菜品，`ingredients`为空数组

---

## 2. 前端UI测试

### 2.1 表单显示测试

#### 测试用例 2.1.1：打开新增菜品表单，显示食材选择器
**测试目标**：验证新增菜品表单包含食材选择器

**测试步骤**：
1. 点击"新增菜品"按钮
2. 观察表单内容

**期望结果**：
- 表单中显示"绑定食材"字段
- 显示Selector组件（多选模式）
- 加载并显示可用的库存食材列表
- 食材选项显示名称和库存数量

---

#### 测试用例 2.1.2：打开编辑菜品表单，预填充已绑定的食材
**测试目标**：验证编辑时正确预填充食材

**前置条件**：
- 菜品`宫保鸡丁`已绑定2个食材

**测试步骤**：
1. 点击菜品的"编辑"按钮
2. 观察表单中的食材字段

**期望结果**：
- 已绑定的2个食材显示为选中状态
- 未绑定的食材显示为未选中状态

---

#### 测试用例 2.1.3：食材列表加载失败的处理
**测试目标**：验证食材列表加载失败时的容错处理

**测试步骤**：
1. 模拟库存API请求失败（断网或服务器错误）
2. 打开新增菜品表单

**期望结果**：
- 显示友好的错误提示："加载食材列表失败"
- 食材选择器显示为空或禁用状态
- 其他表单字段正常可用
- 可以正常提交表单（不绑定食材）

---

### 2.2 食材选择测试

#### 测试用例 2.2.1：选择单个食材
**测试目标**：验证可以选择单个食材

**测试步骤**：
1. 打开新增菜品表单
2. 点击选择"鸡肉"

**期望结果**：
- "鸡肉"显示为选中状态（高亮或勾选标记）
- 表单数据中`ingredients`包含鸡肉的ID

---

#### 测试用例 2.2.2：选择多个食材
**测试目标**：验证可以同时选择多个食材

**测试步骤**：
1. 打开新增菜品表单
2. 依次点击选择"鸡肉"、"花生"、"辣椒"

**期望结果**：
- 3个食材都显示为选中状态
- 表单数据中`ingredients`包含3个ID

---

#### 测试用例 2.2.3：取消选择食材
**测试目标**：验证可以取消已选择的食材

**测试步骤**：
1. 打开新增菜品表单
2. 选择"鸡肉"、"花生"
3. 再次点击"花生"取消选择

**期望结果**：
- "花生"显示为未选中状态
- 表单数据中`ingredients`只包含"鸡肉"的ID

---

#### 测试用例 2.2.4：不选择任何食材
**测试目标**：验证可以不选择食材（可选字段）

**测试步骤**：
1. 打开新增菜品表单
2. 不选择任何食材
3. 填写其他必填字段并提交

**期望结果**：
- 表单可以正常提交
- 提交的数据中`ingredients`为空数组

---

### 2.3 表单提交测试

#### 测试用例 2.3.1：新增菜品时提交绑定的食材
**测试目标**：验证新增菜品时正确提交食材数据

**测试步骤**：
1. 打开新增菜品表单
2. 填写必填字段：名称、价格、分类
3. 选择2个食材："鸡肉"、"花生"
4. 点击"提交"

**期望结果**：
- 发送的POST请求体包含`ingredients`字段
- `ingredients`为数组，包含2个食材ID
- 提交成功后，列表刷新，新菜品出现

---

#### 测试用例 2.3.2：编辑菜品时修改绑定的食材
**测试目标**：验证编辑菜品时可以修改食材绑定

**前置条件**：
- 菜品已绑定`["鸡肉", "花生"]`

**测试步骤**：
1. 打开编辑表单
2. 取消选择"花生"
3. 新增选择"辣椒"
4. 点击"提交"

**期望结果**：
- 发送的PUT请求体包含`ingredients`字段
- `ingredients`为`["鸡肉ID", "辣椒ID"]`
- 提交成功后，列表更新

---

#### 测试用例 2.3.3：编辑菜品时清空所有食材
**测试目标**：验证可以清空所有食材绑定

**前置条件**：
- 菜品已绑定食材

**测试步骤**：
1. 打开编辑表单
2. 取消选择所有食材
3. 点击"提交"

**期望结果**：
- 发送的PUT请求体包含`ingredients`字段，值为空数组`[]`
- 提交成功

---

## 3. 集成测试

### 测试用例 3.1：完整的创建流程
**测试目标**：验证从创建到展示的完整流程

**测试步骤**：
1. 打开新增菜品表单
2. 填写所有字段，选择3个食材
3. 提交表单
4. 查看菜品列表
5. 编辑刚创建的菜品

**期望结果**：
- 表单提交成功
- 后端返回的菜品对象包含正确的`ingredients`
- 列表中新菜品显示正常
- 编辑时正确预填充3个食材

---

### 测试用例 3.2：编辑后查询验证
**测试目标**：验证编辑后数据持久化

**测试步骤**：
1. 编辑一个菜品，修改食材绑定
2. 提交保存
3. 刷新页面
4. 再次编辑该菜品

**期望结果**：
- 修改后的食材绑定正确保存到数据库
- 刷新页面后数据不丢失
- 再次编辑时显示最新的食材绑定

---

### 测试用例 3.3：大量食材的性能测试
**测试目标**：验证大量食材时的性能

**前置条件**：
- 库存中有100+个食材

**测试步骤**：
1. 打开新增菜品表单
2. 观察食材列表加载时间
3. 滚动食材列表
4. 选择多个食材

**期望结果**：
- 食材列表加载时间 < 1秒
- 滚动流畅，无明显卡顿
- 选择操作响应及时

---

## 4. 边界测试

### 测试用例 4.1：选择大量食材（50+）
**测试目标**：验证选择大量食材时的处理

**测试步骤**：
1. 打开新增菜品表单
2. 选择50个以上的食材
3. 提交表单

**期望结果**：
- 可以正常选择和提交
- 后端正确保存所有食材ID
- UI展示不出现异常

---

### 测试用例 4.2：食材ID重复处理
**测试目标**：验证重复食材ID的去重处理

**测试步骤**：
1. 手动构造请求体，包含重复的食材ID
2. 发送到后端

**期望结果**：
- 后端自动去重（推荐）或拒绝请求并返回错误

---

### 测试用例 4.3：绑定已删除的食材
**测试目标**：验证绑定的食材被删除后的处理

**前置条件**：
- 菜品A绑定了食材X
- 食材X被软删除或硬删除

**测试步骤**：
1. 查询菜品A的详情
2. 编辑菜品A

**期望结果**：
- 查询时正常返回食材ID（即使食材已删除）
- 编辑时食材列表中不显示已删除的食材
- 不影响菜品的其他功能

---

## 5. 兼容性测试

### 测试用例 5.1：旧版菜品数据兼容
**测试目标**：验证旧数据（没有ingredients字段）的兼容性

**前置条件**：
- 数据库中存在没有`ingredients`字段的旧菜品

**测试步骤**：
1. 查询旧菜品
2. 编辑旧菜品

**期望结果**：
- 查询时`ingredients`显示为空数组`[]`
- 编辑时可以正常添加食材
- 保存后字段正常更新

---

## 6. 测试总结

### 测试覆盖率统计

| 测试类型 | 测试用例数 | 优先级 |
|---------|-----------|--------|
| 后端API测试 | 11 | P0 |
| 前端UI测试 | 10 | P0 |
| 集成测试 | 3 | P1 |
| 边界测试 | 3 | P1 |
| 兼容性测试 | 1 | P2 |
| **总计** | **28** | - |

### 测试执行建议

**第一轮（核心功能）**：
- 执行所有P0优先级测试用例
- 确保基本功能可用

**第二轮（完整测试）**：
- 执行P1和P2优先级测试用例
- 验证边界情况和兼容性

**回归测试**：
- 每次修改代码后，重新执行核心测试用例
- 确保新改动不影响已有功能

---

## 7. 测试环境

### 测试工具
- **后端API测试**：Postman / curl / Jest
- **前端UI测试**：手动测试 / Cypress
- **集成测试**：手动测试 / Playwright

### 测试数据
参考：[测试数据准备脚本](./test-data-preparation.md)

---

## 8. 缺陷追踪

| 缺陷ID | 描述 | 严重程度 | 状态 |
|-------|------|---------|------|
| - | - | - | - |

---

**测试负责人**：待定  
**测试周期**：预计2天  
**文档版本**：v1.0  
**更新日期**：2026-01-30
