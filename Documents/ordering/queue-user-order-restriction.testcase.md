# 排队用户创建订单限制测试用例

## 测试目标
验证排队中的用户无法创建订单，只有已分配座位的用户才能创建订单

## 测试环境准备

### 前置条件
1. 后端服务正常运行（端口：3001）
2. 前端服务正常运行（端口：3000）
3. MongoDB数据库连接正常
4. Redis服务正常运行
5. 已创建测试用户账号

### 测试数据准备
1. 确保系统中有足够的菜品数据
2. 至少有1个可用座位
3. 准备2个测试用户账号（user1, user2）

## 测试用例

### 测试用例1：排队用户尝试创建订单（后端验证）

**测试步骤**：
1. 使用user1登录系统
2. 进入点餐界面，确保所有座位都被占用，用户进入排队状态
3. 通过AI对话或手动选择添加菜品到购物车
4. 点击"支付"按钮尝试创建订单

**预期结果**：
- 后端返回错误：`{ code: 400, message: '您还未分配座位，无法创建订单' }`
- 前端显示Toast提示："您还未分配座位，无法创建订单"
- 购物车内容保持不变（不被清空）
- 订单未被创建到数据库中

**验证点**：
- [ ] HTTP响应状态码为 400
- [ ] 错误消息准确提示排队状态
- [ ] 购物车数据未被清空
- [ ] MongoDB的orders集合中没有新订单

---

### 测试用例2：排队用户前端UI限制

**测试步骤**：
1. 使用user1登录系统
2. 进入点餐界面，确保用户处于排队状态（queueInfo存在，seatInfo为null）
3. 通过AI对话或手动选择添加菜品到购物车
4. 观察"支付"按钮状态

**预期结果**：
- 导航栏显示："排队中：第X位"（橙色标签）
- AI推荐菜单卡片底部：
  - "刷新"按钮正常可用
  - "支付"按钮显示为禁用状态（灰色）
  - 鼠标悬停显示提示："请等待座位分配后再支付"
- 菜单Popup底部：
  - "确认选择"按钮正常可用（只是更新购物车）
  - "支付"按钮禁用且显示提示
- 点击禁用的支付按钮无响应

**验证点**：
- [ ] 排队状态正确显示
- [ ] 支付按钮禁用状态正确
- [ ] 提示信息友好清晰
- [ ] 刷新和购物车编辑功能不受影响

---

### 测试用例3：已分配座位用户可正常创建订单

**测试步骤**：
1. 使用user2登录系统
2. 进入点餐界面，系统自动分配座位（seatInfo存在）
3. 通过AI对话或手动选择添加菜品到购物车
4. 点击"支付"按钮创建订单

**预期结果**：
- 导航栏显示："座位：X号"（绿色标签）
- "支付"按钮正常可用（绿色/成功色）
- 订单创建成功
- 返回订单号和总金额
- 购物车被清空
- 显示游戏推荐消息

**验证点**：
- [ ] 座位状态正确显示
- [ ] 支付按钮可用
- [ ] 订单成功创建
- [ ] 购物车被清空
- [ ] 订单数据正确保存到数据库

---

### 测试用例4：排队用户分配座位后可创建订单

**测试步骤**：
1. 使用user1登录系统，进入排队状态
2. 添加菜品到购物车（支付按钮禁用）
3. 商家端释放一个座位或叫号
4. user1自动获得座位分配（seatAssigned事件）
5. 观察支付按钮状态变化
6. 点击"支付"按钮创建订单

**预期结果**：
- 用户收到座位分配通知："已分配座位：X号"
- 导航栏从"排队中"变为"座位：X号"
- 支付按钮从禁用变为可用
- 购物车内容保持不变
- 点击支付成功创建订单

**验证点**：
- [ ] WebSocket事件正确接收
- [ ] UI状态实时更新
- [ ] 支付按钮状态动态切换
- [ ] 订单创建成功

---

### 测试用例5：购物车操作不受排队状态影响

**测试步骤**：
1. 使用user1登录系统，进入排队状态
2. 通过AI对话添加菜品
3. 点击"刷新"按钮重新推荐菜品
4. 打开菜单Popup修改菜品数量
5. 点击"确认选择"更新购物车

**预期结果**：
- 所有购物车操作正常执行
- 刷新功能正常工作
- 菜品数量修改生效
- 购物车实时更新
- 只有支付功能被限制

**验证点**：
- [ ] 刷新菜单功能正常
- [ ] 购物车编辑功能正常
- [ ] API调用成功
- [ ] 只有创建订单被限制

---

## 边界测试

### 边界测试1：座位状态异常处理

**测试场景**：
- Redis中的座位占用信息与实际状态不一致

**测试步骤**：
1. 手动修改Redis中的座位占用信息
2. 用户尝试创建订单

**预期结果**：
- 后端正确判断用户是否有座位
- 返回准确的错误提示
- 不会造成数据不一致

---

### 边界测试2：网络断连后重连

**测试场景**：
- 用户排队期间网络断开再重连

**测试步骤**：
1. 用户排队中
2. 断开网络连接
3. 重新连接网络
4. 尝试创建订单

**预期结果**：
- WebSocket自动重连
- 排队位置重新获取
- 支付按钮状态正确
- 座位状态准确反映

---

## 自动化测试脚本

### 后端API测试（Jest/Postman）

```javascript
describe('创建订单 - 排队用户限制', () => {
  let queueUserToken;
  let seatedUserToken;
  
  beforeAll(async () => {
    // 准备测试用户token
    queueUserToken = await loginUser('queue_user');
    seatedUserToken = await loginUser('seated_user');
  });
  
  test('排队用户创建订单应该失败', async () => {
    // 1. 添加菜品到购物车
    await addToCart(queueUserToken, [
      { dishId: 'dish1', quantity: 2 }
    ]);
    
    // 2. 尝试创建订单
    const response = await request(app)
      .post('/api/ordering/create-order')
      .set('Authorization', `Bearer ${queueUserToken}`)
      .send({ note: '测试订单' });
    
    // 3. 验证响应
    expect(response.status).toBe(400);
    expect(response.body.message).toContain('未分配座位');
    
    // 4. 验证购物车未被清空
    const cart = await getCart(queueUserToken);
    expect(cart.dishes.length).toBeGreaterThan(0);
  });
  
  test('已分配座位用户创建订单应该成功', async () => {
    // 1. 添加菜品到购物车
    await addToCart(seatedUserToken, [
      { dishId: 'dish1', quantity: 2 }
    ]);
    
    // 2. 创建订单
    const response = await request(app)
      .post('/api/ordering/create-order')
      .set('Authorization', `Bearer ${seatedUserToken}`)
      .send({ note: '测试订单' });
    
    // 3. 验证响应
    expect(response.status).toBe(201);
    expect(response.body.data.orderId).toBeDefined();
    
    // 4. 验证购物车被清空
    const cart = await getCart(seatedUserToken);
    expect(cart.dishes.length).toBe(0);
  });
});
```

---

## 测试报告模板

| 测试用例 | 执行结果 | 执行人 | 执行时间 | 备注 |
|---------|---------|--------|----------|------|
| 测试用例1 | ✅/❌ | | | |
| 测试用例2 | ✅/❌ | | | |
| 测试用例3 | ✅/❌ | | | |
| 测试用例4 | ✅/❌ | | | |
| 测试用例5 | ✅/❌ | | | |
| 边界测试1 | ✅/❌ | | | |
| 边界测试2 | ✅/❌ | | | |

---

## 常见问题排查

### 问题1：支付按钮未禁用
**可能原因**：
- queueInfo状态未正确设置
- WebSocket连接异常
- 前端逻辑判断错误

**排查方法**：
1. 检查浏览器控制台WebSocket事件
2. 检查React状态：`console.log(queueInfo, seatInfo)`
3. 验证socket事件监听器

### 问题2：后端验证不生效
**可能原因**：
- Redis中座位状态不准确
- Socket ID映射错误
- 用户ID获取失败

**排查方法**：
1. 检查Redis数据：`redis-cli KEYS seat:*`
2. 查看后端日志
3. 验证JWT token解析

### 问题3：购物车被清空
**可能原因**：
- 错误处理逻辑有误
- API调用顺序问题

**排查方法**：
1. 检查createOrder方法中的try-catch
2. 确认购物车清空只在订单成功时执行
3. 查看数据库事务处理
