# 订单 Socket 实时更新 - 测试用例

## 测试目标
验证订单列表通过 Socket.IO 实时更新功能是否正常工作

## 测试环境
- **后端**: NestJS + Socket.IO (namespace: `/order`)
- **前端**: React + socket.io-client
- **浏览器**: Chrome/Safari/Firefox

---

## 测试用例 1: Socket 连接建立

### 测试步骤
1. 打开浏览器开发者工具（Console）
2. 导航到订单列表页面 `/merchant/orders`
3. 检查控制台日志

### 期望结果
- ✅ 控制台输出：`初始化订单 Socket 连接...`
- ✅ 控制台输出：`订单 Socket 已连接: <socket-id>`
- ✅ 后端日志显示：`订单客户端连接: <socket-id>`

### 验证点
- Socket 连接到正确的 namespace (`/order`)
- 连接成功且获得唯一的 socket ID

---

## 测试用例 2: 新订单创建实时通知

### 前置条件
- 商家端已打开订单列表页面
- 用户端已登录并有菜品在购物车

### 测试步骤
1. **商家端**: 打开订单列表页面（保持页面打开）
2. **用户端**: 点击"支付"按钮创建订单
3. **商家端**: 观察订单列表页面

### 期望结果
- ✅ 商家端控制台输出：`收到订单更新通知: { event: 'created', order: {...} }`
- ✅ 页面显示 Toast 提示：`新订单`（中文）或 `New Order`（英文）
- ✅ 订单列表**自动刷新**，新订单出现在列表顶部
- ✅ 后端日志显示：`广播订单更新: created, 订单ID: <order-id>`

### 验证点
- 无需手动下拉刷新，页面自动更新
- 新订单状态为 `pending`
- 订单信息完整（菜品、价格、用户名）

---

## 测试用例 3: 订单状态变更实时通知

### 前置条件
- 商家端已打开订单列表页面
- 系统中存在至少一个 `pending` 状态的订单

### 测试步骤
1. **设备A（商家端）**: 打开订单列表页面
2. **设备B（商家端）**: 在另一个浏览器/设备打开订单列表
3. **设备B**: 点击某订单的"接单"按钮（状态: pending → preparing）
4. **设备A**: 观察订单列表

### 期望结果
- ✅ **设备A** 控制台输出：`收到订单更新通知: { event: 'statusChanged', order: {...} }`
- ✅ **设备A** 页面显示 Toast 提示：`订单已更新`
- ✅ **设备A** 订单列表自动刷新，该订单状态更新为 `preparing`
- ✅ 后端日志显示：`广播订单更新: statusChanged, 订单ID: <order-id>`

### 验证点
- 多设备/多浏览器的订单状态同步
- 状态颜色和文字正确更新
- 操作按钮正确变化（如"接单" → "完成"）

---

## 测试用例 4: 订单完成通知

### 测试步骤
1. 商家端在订单列表找到 `preparing` 状态的订单
2. 点击"完成订单"按钮（状态: preparing → completed）
3. 观察所有打开的订单列表页面

### 期望结果
- ✅ 所有页面同步显示订单状态变为 `completed`
- ✅ Toast 提示显示
- ✅ 列表自动刷新

---

## 测试用例 5: 切换标签时 Socket 保持连接

### 测试步骤
1. 打开订单列表页面（默认"全部订单"标签）
2. 切换到"待处理"标签
3. 切换到"制作中"标签
4. 在另一设备创建新订单
5. 观察当前页面

### 期望结果
- ✅ 切换标签时 Socket 连接**不断开**
- ✅ 控制台无 `订单 Socket 已断开` 日志
- ✅ 新订单通知仍然正常接收
- ✅ 列表根据当前标签过滤后自动刷新

---

## 测试用例 6: 离开页面时清理 Socket 连接

### 测试步骤
1. 打开订单列表页面，确认 Socket 已连接
2. 记录控制台显示的 socket ID
3. 导航离开页面（如返回商家首页）
4. 检查控制台日志

### 期望结果
- ✅ 控制台输出：`清理订单 Socket 连接`
- ✅ 控制台输出：`订单 Socket 已断开`
- ✅ 后端日志显示：`订单客户端断开: <socket-id>`

### 验证点
- Socket 连接被正确释放，无内存泄漏
- 后端不再向该 socket ID 推送消息

---

## 测试用例 7: 网络断开重连

### 测试步骤
1. 打开订单列表页面
2. 使用浏览器开发者工具模拟离线（Network → Offline）
3. 等待 5 秒
4. 恢复网络连接（Network → Online）
5. 在另一设备创建订单

### 期望结果
- ✅ 离线时控制台显示：`订单 Socket 已断开`
- ✅ 恢复网络后 Socket 自动重连（可能需要刷新页面）
- ✅ 重连后能正常接收订单更新通知

---

## 测试用例 8: 多订单并发创建

### 测试步骤
1. 商家端打开订单列表
2. 使用 3 个不同用户端几乎同时创建订单（间隔 <1 秒）
3. 观察商家端列表

### 期望结果
- ✅ 所有 3 个订单的创建通知都能接收
- ✅ 列表自动刷新，显示全部 3 个新订单
- ✅ 订单顺序正确（按创建时间倒序）
- ✅ 无订单丢失或重复

---

## 测试用例 9: Socket namespace 隔离

### 测试目标
验证订单 Socket (`/order`) 与座位 Socket (`/seat`) 互不干扰

### 测试步骤
1. 同时打开订单列表页面和座位管理页面
2. 在控制台观察 Socket 连接
3. 创建新订单
4. 申请座位

### 期望结果
- ✅ 控制台显示**两个独立的 Socket 连接**
  - `订单 Socket 已连接: <order-socket-id>`
  - `Merchant socket connected: <seat-socket-id>`（从座位管理）
- ✅ 订单事件只触发订单列表刷新
- ✅ 座位事件只触发座位列表刷新
- ✅ 两个 namespace 不相互影响

---

## 性能测试

### 测试用例 10: 频繁订单更新性能

### 测试步骤
1. 商家端打开订单列表
2. 快速连续创建 10 个订单
3. 观察页面响应和性能

### 期望结果
- ✅ 页面不卡顿，响应流畅
- ✅ 每个订单通知都能接收
- ✅ Toast 提示不重叠（自动消失后显示下一个）
- ✅ 列表刷新不闪烁

---

## 异常情况测试

### 测试用例 11: 后端服务重启

### 测试步骤
1. 打开订单列表页面，Socket 已连接
2. 重启后端服务（`npm run start:dev`）
3. 等待后端启动完成
4. 创建新订单

### 期望结果
- ✅ 重启期间前端显示：`订单 Socket 已断开`
- ✅ 后端启动后，Socket 自动重连（或页面刷新后重连）
- ✅ 重连后功能正常

---

## 回归测试

### 测试用例 12: 原有功能不受影响

### 验证点
- ✅ 手动下拉刷新仍然可用
- ✅ 切换订单状态标签仍然正常过滤
- ✅ 无限滚动加载更多订单仍然有效
- ✅ 更新订单状态按钮功能正常
- ✅ 订单详情显示完整

---

## 测试工具

### 浏览器开发者工具检查
```javascript
// 在控制台运行，查看 Socket 状态
console.log('Socket 连接状态:', socket?.connected);
console.log('Socket ID:', socket?.id);
```

### 后端日志检查
```bash
# 监控后端日志
cd /Users/bzhang1/Desktop/Ai-chat-Demo/ChatBackEnd
npm run start:dev
# 查看日志中的 Socket 相关输出
```

---

## 测试通过标准

- ✅ 所有 12 个测试用例通过
- ✅ 无控制台错误或警告
- ✅ Socket 连接稳定，无频繁断开重连
- ✅ 多设备同步准确无延迟
- ✅ 原有订单管理功能不受影响
