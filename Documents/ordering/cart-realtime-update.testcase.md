# 购物车实时更新功能测试用例

## 功能概述
在聊天窗口的菜单popup中，用户通过Stepper修改菜品数量时，实时调用购物车编辑API，将修改同步到后端购物车，而不是等到点击"确认选择"按钮时才更新。

## 测试环境
- 前端：http://localhost:3000
- 后端：http://localhost:3001
- 测试账号：任意注册用户

---

## 测试用例1：实时更新购物车 - 增加数量

### 测试步骤
1. 登录系统，进入智能点餐页面
2. 点击右上角菜单图标打开菜单列表
3. 在某个菜品上点击"+"按钮，增加数量
4. 观察网络请求

### 预期结果
- ✅ 点击"+"后，立即发送PUT请求到 `/api/ordering/cart`
- ✅ 请求体包含修改后的购物车数据
- ✅ 不需要点击"确认选择"即可完成更新
- ✅ 后端购物车数据立即更新

### 验证方法
```bash
# 查看购物车内容，确认数量已更新
curl -X GET http://localhost:3001/api/ordering/cart \
  -H "Authorization: Bearer YOUR_TOKEN"
```

---

## 测试用例2：实时更新购物车 - 减少数量

### 测试步骤
1. 在已有数量的菜品上点击"-"按钮，减少数量
2. 观察网络请求
3. 继续减少直到数量为0

### 预期结果
- ✅ 点击"-"后，立即发送PUT请求到 `/api/ordering/cart`
- ✅ 数量减为0时，该菜品从购物车中移除
- ✅ 后端购物车数据立即更新

---

## 测试用例3：连续快速修改数量（防抖测试）

### 测试步骤
1. 快速连续点击某个菜品的"+"或"-"按钮多次
2. 观察网络请求发送频率

### 预期结果
- ✅ 使用防抖机制，避免过于频繁的API调用
- ✅ 最终购物车数据与前端显示一致
- ✅ 不会因为频繁请求导致数据不一致

---

## 测试用例4：网络失败处理

### 测试步骤
1. 断开网络连接（或使用浏览器DevTools模拟离线）
2. 修改菜品数量
3. 恢复网络连接

### 预期结果
- ✅ 网络失败时显示错误提示
- ✅ 前端状态仍然更新（用户可以继续操作）
- ⚠️ 用户需要点击"确认选择"时重新同步数据

---

## 测试用例5：多个菜品同时修改

### 测试步骤
1. 打开菜单列表
2. 修改菜品A的数量
3. 立即修改菜品B的数量
4. 再次打开菜单，查看数据

### 预期结果
- ✅ 每次修改都会触发购物车更新
- ✅ 所有修改的数据都正确保存
- ✅ 重新打开菜单时，显示最新的数据

---

## 测试用例6：从AI推荐菜单中修改

### 测试步骤
1. 输入点餐需求，获取AI推荐菜单
2. 点击菜单卡片打开编辑页面
3. 修改推荐菜品的数量
4. 观察购物车更新

### 预期结果
- ✅ 修改数量时立即更新购物车
- ✅ AI推荐的数量作为初始值
- ✅ 修改后的数据保存到购物车

---

## 测试用例7：与"确认选择"按钮的兼容性

### 测试步骤
1. 打开菜单列表
2. 修改若干菜品数量（触发实时更新）
3. 继续修改更多菜品
4. 点击"确认选择"按钮

### 预期结果
- ✅ 已实时更新的菜品不会重复提交
- ✅ "确认选择"按钮仍然正常工作
- ✅ 购物车数据保持一致
- ✅ 点击后关闭popup并显示成功提示

---

## 性能测试

### 测试场景
- 快速连续修改10个菜品的数量
- 观察响应时间和网络请求数量

### 性能指标
- ✅ 单次更新响应时间 < 500ms
- ✅ 使用防抖后，API调用次数合理
- ✅ UI不卡顿，操作流畅

---

## 回归测试

### 确保不影响现有功能
1. ✅ AI点餐功能正常
2. ✅ 创建订单功能正常
3. ✅ 订单历史查询正常
4. ✅ 菜单刷新功能正常

---

## 测试总结

### 核心验证点
1. **实时性**：修改数量时立即调用API
2. **准确性**：购物车数据与前端显示一致
3. **稳定性**：网络异常时不影响用户体验
4. **性能**：防抖机制避免过度请求
5. **兼容性**：与现有功能无冲突
